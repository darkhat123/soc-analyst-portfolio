# Scenario
As a malware analyst at CyberResponse Inc., you are tasked with investigating a piece of malware that has been reported to steal sensitive information like passwords, keystrokes, and screenshots. Your goal is to dissect the malware sample, understand its components, and uncover its attack methods. This task is crucial for developing countermeasures to protect users and organizations.

# Introduction
As the scenario explains, this malware is whats most commonly known as a stealer malware, which main purpose is to extract credentials, assets and the behaviour of the victim. This sample is a popular malware still in use today, typicallly AgentTesla is part of a multi stage
attack which involves infecting the computer with the AgentTesla malware using packing and polymorphism to mask the signature of the antivirus code inside the dropper program. Once decrypted the payload is then injected into memory 
in a fileless injection attack.

## Question 1 Identifying the scripting engine or interpreter used in malware can provide insights into its functionality and potential behaviors. What is the name of the scripting engine embedded in this executable?
When looking to find the scripting engine it can typically be found using static analysis tools, one of the most important steps when beginning a malware analysis is to determine the true file type of the malware as it can be
easily masked by changing the extension. DetectItEasy will look inside the file and look at the patterns within the files contents to determie the file type. It also gathers information on:
1. Compiler
2. Language used
3. Developer tool
4. Intended Operating System
5. Scripting Engine

These are all things that can be used to tell us what we can expect when we begin to look closer into the files contents

If we run DetectItEasy and load the file, we can see that the Scripting Engine is listed under the **Format** section
<img width="1918" height="992" alt="image" src="https://github.com/user-attachments/assets/9fb87a73-9eb1-4a82-8685-7cfd8716b9f8" />

Answer: Autoit

## Question 2 Determining the hash of executable components is essential for verifying integrity and identifying malware. When the malware is executed, there are scripts running, one of them is a bin file. What is the MD5 hash of this file?
Knowing the hash of the bin file we are looking for requires the malware to be ran in a controlled environment and is acquired at runtime. We know that the file was written using the scripting language autoit. You can think of autoit like windows version of bash scripting with some more powerful features native to windows.
Its capable of performing gui automation making it particularly useful in tools such as Botnet Clients and Remote Access Trojans. Once the program is built it can be compiled into a Poratble Executable format which can then be run on any supporting operating system.
This likely means that the initial program is being used as a dropper, this is gathered from the common use of autoit programs being used to obfsucate the true payload in previous attacks where the autoit program was used to bypass antivirus programs appearing like a harmless portable executable, which once the malicious code is unpacked will download a secondary stage payload into the memory of the computer using process injection..

In order to extract the source code the autoit extractor will attempt to return the bytecode used by the machine back into the native language. Before this can be done we must unpack the malware, if we refer to our previous screenshot we can determine the packing software used was UPX.
With this knowledge we can use the software to unpack the malware into its original form.

<img width="1883" height="920" alt="image" src="https://github.com/user-attachments/assets/90b7adc8-be7f-4a54-bbdf-0bba64ae9431" />

Command Used: `upx.lnk -d "C:\Users\Administrator\Desktop\Start Here\Artifacts\DHL008976.exe" -o "C:\Users\Administrator\Desktop\Start Here\Artifacts\DHL008976.exe.dat"`

Make sure all programs using the file are closed and the file is not in use anywhere on the pc before running this command from the **Packers** directory

Now when we run autoit and load the unpacked malware in it can begin to try and return the resources embedded in the autoit file, this is a good way to extract the files that may be responsible for futher malicious actions 
<img width="1777" height="877" alt="image" src="https://github.com/user-attachments/assets/10409f36-19dd-4ffc-b2da-8025900c396b" />

Two files are returned, if we use the **Save Resource** function we can save these files to the computer where we can peform further analysis on their contents.

With the resource saved we now simply use HashMyFiles to determine multiple hashes for the suspect file
<img width="1911" height="904" alt="image" src="https://github.com/user-attachments/assets/75c15f22-29aa-412e-9bdc-bfa204212ceb" />

Answer: a657189456d164a28b0eb9f5a2654b26

## Question 3 Recognizing key methods in the malware's code helps to pinpoint its main functionalities. What is the name of the method that has main logging functionalities, such as keylogging and screen logging?
Now that we know that the malware is likely being injected into a process using the autoit script, we can open up process hacker and then run the Malicious program and observe what processes are created upon the execution of the program.
We can then gather the process id of the running program and use pe-seive to obtain the memory of a process in a memory dump. This can then be used to view the true payload within the memory.

First we will extract the memory using pe-sieve, supplying the process ID of the malicious program.
<img width="1912" height="917" alt="image" src="https://github.com/user-attachments/assets/97422adf-4633-4e21-9a74-12c756b3ef48" />

Command Used: `pe-sieve /pid 2120`

Now that we have the memory dump of the process 
